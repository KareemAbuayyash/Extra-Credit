name: Payroll App Deployment Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  checks: write

env:
  AWS_REGION: us-east-1
  ECR_REPO: payroll-app
  ECS_CLUSTER_NAME: payroll-app-cluster
  ECS_SERVICE_NAME: payroll-app-task
  APP_CONTAINER_NAME: payroll-app

jobs:
  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  # VALIDATE & PACKAGE
  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  validate-and-package:
    runs-on: ubuntu-latest
    name: Test & Package Application
    
    outputs:
      image: ${{ steps.container-build.outputs.image }}
    
    steps:
    - name: Source Code Checkout
      uses: actions/checkout@v4
      
    - name: Configure Java Environment
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Maven Dependency Cache
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
        
    - name: Execute Test Suite
      run: |
        echo "Executing comprehensive validation..."
        mvn clean test -B
        
    - name: Test Report Generation
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Test Results
        path: target/surefire-reports/*.xml
        reporter: java-junit
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Application Packaging
      run: |
        echo "Creating production package..."
        mvn clean package -DskipTests -B

    - name: AWS Environment Setup
      if: github.ref == 'refs/heads/main'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: ECR Authentication
      if: github.ref == 'refs/heads/main'
      id: ecr-auth
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Container Build & Registry Push
      if: github.ref == 'refs/heads/main'
      id: container-build
      env:
        ECR_REGISTRY: ${{ steps.ecr-auth.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Containerizing application..."
        docker build -t $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPO:latest .
        
        echo "Publishing to container registry..."
        docker push $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPO:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Container registry update completed"

  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  # INFRASTRUCTURE DEPLOYMENT
  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  infrastructure-deployment:
    runs-on: ubuntu-latest
    needs: validate-and-package
    name: Live Environment Provisioning
    if: github.ref == 'refs/heads/main'
    
    outputs:
      endpoint: ${{ steps.service-discovery.outputs.endpoint }}
    
    steps:
    - name: Cloud Provider Authentication
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: us-east-1
        
    - name: Production Environment Provisioning
      run: |
        echo "Initiating production deployment..."
        
        # Clean existing deployment
        EXISTING_TASKS=$(aws ecs list-tasks --cluster payroll-app-cluster --query 'taskArns' --output text)
        if [ "$EXISTING_TASKS" != "" ]; then
          echo "Retiring previous deployment..."
          for task in $EXISTING_TASKS; do
            TASK_ID=$(echo $task | cut -d'/' -f3)
            aws ecs stop-task --cluster payroll-app-cluster --task $TASK_ID --reason "Production update"
          done
          sleep 30
        fi
        
        # Production configuration template
        cat > deployment-config.json << 'EOF'
        {
          "family": "payroll-app-task",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "1024",
          "memory": "4096",
          "executionRoleArn": "arn:aws:iam::562437922263:role/LabRole",
          "taskRoleArn": "arn:aws:iam::562437922263:role/LabRole",
          "containerDefinitions": [
            {
              "name": "payroll-app",
              "image": "${{ needs.validate-and-package.outputs.image }}",
              "portMappings": [{"containerPort": 8080, "protocol": "tcp"}],
              "memory": 4096,
              "environment": [
                {"name": "SPRING_PROFILES_ACTIVE", "value": "dev"},
                {"name": "JAVA_OPTS", "value": "-Xmx1024m -Xms512m -XX:+UseContainerSupport -XX:MaxRAMPercentage=50.0"},
                {"name": "ENVIRONMENT_PROFILE", "value": "dev"},
                {"name": "SERVER_PORT", "value": "8080"}
              ],
              "healthCheck": {
                "command": [
                  "CMD-SHELL",
                  "curl -f http://localhost:8080/actuator/health || exit 1"
                ],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 120
              },
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/payroll-app",
                  "awslogs-region": "us-east-1",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        
        echo "Production specifications:"
        echo "→ Memory: 2GB allocated"
        echo "→ CPU: 1 vCPU assigned"
        echo "→ Java heap: 1GB optimized"
        echo "→ Health monitoring: Active"
        
        # Service definition registration
        DEPLOYMENT_ARN=$(aws ecs register-task-definition --cli-input-json file://deployment-config.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "Service definition created: $DEPLOYMENT_ARN"
        
        # Network infrastructure discovery
        PRIMARY_VPC=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
        AVAILABLE_SUBNETS=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$PRIMARY_VPC Name=map-public-ip-on-launch,Values=true --query 'Subnets[*].SubnetId' --output text | tr '\t' ',')
        ACCESS_RULES=$(aws ec2 describe-security-groups --filters Name=group-name,Values=payroll-sg --query 'SecurityGroups[0].GroupId' --output text)
        
        # Service activation
        echo "Activating production service..."
        DEPLOYMENT=$(aws ecs run-task \
          --cluster payroll-app-cluster \
          --task-definition $DEPLOYMENT_ARN \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$AVAILABLE_SUBNETS],securityGroups=[$ACCESS_RULES],assignPublicIp=ENABLED}" \
          --query 'tasks[0].taskArn' --output text)
          
        echo "Production service activated: $DEPLOYMENT"
        
        # Deployment verification
        DEPLOYMENT_ID=$(echo $DEPLOYMENT | cut -d'/' -f3)
        
        for iteration in {1..20}; do
          CURRENT_STATUS=$(aws ecs describe-tasks --cluster payroll-app-cluster --tasks $DEPLOYMENT_ID --query 'tasks[0].lastStatus' --output text)
          echo "Production status ($iteration/20): $CURRENT_STATUS"
          
          if [ "$CURRENT_STATUS" = "RUNNING" ]; then
            echo "Production deployment successful!"
            break
          elif [ "$CURRENT_STATUS" = "STOPPED" ]; then
            echo "Production deployment failed - service stopped"
            aws ecs describe-tasks --cluster payroll-app-cluster --tasks $DEPLOYMENT_ID --query 'tasks[0].[stoppedReason,containers[0].exitCode,containers[0].reason]' --output table
            exit 1
          fi
          
          sleep 15
        done

    - name: Service Endpoint Discovery
      id: service-discovery
      run: |
        echo "Locating service endpoint..."
        
        for discovery_attempt in {1..5}; do
          echo "Endpoint discovery attempt $discovery_attempt/5..."
          
          ACTIVE_SERVICES=$(aws ecs list-tasks --cluster payroll-app-cluster --desired-status RUNNING --query 'taskArns' --output text)
          
          if [ "$ACTIVE_SERVICES" != "" ]; then
            PRIMARY_SERVICE=$(echo $ACTIVE_SERVICES | cut -d' ' -f1)
            SERVICE_ID=$(echo $PRIMARY_SERVICE | cut -d'/' -f3)
            
            NETWORK_ADAPTER=$(aws ecs describe-tasks --cluster payroll-app-cluster --tasks $SERVICE_ID --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text 2>/dev/null)
            
            if [ "$NETWORK_ADAPTER" != "" ] && [ "$NETWORK_ADAPTER" != "None" ]; then
              EXTERNAL_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $NETWORK_ADAPTER --query 'NetworkInterfaces[0].Association.PublicIp' --output text 2>/dev/null)
              
              if [ "$EXTERNAL_IP" != "" ] && [ "$EXTERNAL_IP" != "None" ]; then
                echo "Service endpoint located: $EXTERNAL_IP"
                break
              fi
            fi
          fi
          
          sleep 10
        done
        
        if [ "$EXTERNAL_IP" = "" ] || [ "$EXTERNAL_IP" = "None" ]; then
          echo "Endpoint discovery failed after 5 attempts"
          exit 1
        fi
        
        SERVICE_ENDPOINT="http://$EXTERNAL_IP:8080"
        echo "endpoint=$SERVICE_ENDPOINT" >> $GITHUB_OUTPUT
        
        echo ""
        echo "🎯 INFRASTRUCTURE PROVISIONED!"
        echo ""
        echo "Service Access Points:"
        echo "  → Primary Service: $SERVICE_ENDPOINT"
        echo "  → Health Monitor: $SERVICE_ENDPOINT/actuator/health"
        echo "  → API Documentation: $SERVICE_ENDPOINT/api-docs-ui"
        echo "  → Interactive Docs: $SERVICE_ENDPOINT/swagger-ui/index.html"
        echo "  → Employee Service: $SERVICE_ENDPOINT/employees"
        echo "  → Authentication: $SERVICE_ENDPOINT/auth/login"
        echo ""

  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  # DEPLOYMENT VERIFICATION
  # ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
  deployment-verification:
    runs-on: ubuntu-latest
    needs: [validate-and-package, infrastructure-deployment]
    name: Production Readiness Validation
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Service Health Verification
      run: |
        SERVICE_URL="${{ needs.infrastructure-deployment.outputs.endpoint }}"
        
        echo "Conducting production readiness verification..."
        
        for health_check in {1..10}; do
          echo "Readiness check $health_check/10..."
          
          if curl -f -s --connect-timeout 5 --max-time 10 $SERVICE_URL/actuator/health > /dev/null 2>&1; then
            echo "✅ Production readiness confirmed!"
            SERVICE_HEALTH=$(curl -s $SERVICE_URL/actuator/health 2>/dev/null)
            echo "Service Health Report: $SERVICE_HEALTH"
            break
          else
            if [ $health_check -eq 10 ]; then
              echo "⚠️ Health verification timeout - service may still be initializing"
            else
              sleep 15
            fi
          fi
        done

    - name: Pipeline Completion Report
      run: |
        echo ""
        echo "🎊 DEPLOYMENT PIPELINE COMPLETED!"
        echo ""
        echo "Production Environment Details:"
        echo "  → Container Image: ${{ needs.validate-and-package.outputs.image }}"
        echo "  → Live Service URL: ${{ needs.infrastructure-deployment.outputs.endpoint }}"
        echo "  → Memory Configuration: 2GB optimized"
        echo "  → CPU Configuration: 1 vCPU dedicated"
        echo "  → Health Monitoring: Fully operational"
        echo ""
        echo "Your Payroll Application is now live in production!"
        echo "Future commits to main branch will trigger automatic updates."
        echo ""